---
title: "Typehero Beginners 题解"
tags: ["TypeScript", "typehero.dev"]
createdAt: "2026-01-01"
summary: "Typehero.dev Beginner 题目讲解和答案分析"
---

## Hello World

```ts
type HelloWorld = string
```

string 和 String 不同的概念：

- string 是 TS 中的字符串类型
- String 是 JS 中的构造函数

## Generic Function Arguments

### 为何函数需要泛型

若函数只处理 string、number 等原始类型时还好，一旦需要处理自定义类型或是返回自定义类型时，便需要使用泛型。

在 Generic Type Arguments 中定义了 Row 类型：

```ts
interface Row<T> {
  label: string
  value: T
  disabled: boolean
}
```

假设函数 `createRow` 的返回值是 `Row` 类型的对象：

```ts
const createRow = (
  label: string,

  // 我们该如何设置 value 的类型呢？
  value: unknown,

  disabled = false,
) => ({
  label,
  value,
  disabled,
})
```

我们同样可以使用 `<` 和 `>`，在函数参数的 `(` 之前定义函数参数的类型：

```ts
const createRow = <T>(label: string, value: T, disabled = false) => ({
  //...
})
```

> 上面的代码中之所以写成 `<T,>` 是为了和 React 组件做区分
>
> {/* prettier-ignore-start */}
>
> ```tsx
> // 此处的 <T> 是 JSX 语法
> const createRow = <T>Some JSX stuff!</T>;
>
> // 此处的 <T> 是 函数泛型
> const createRow = <T>(someArg: T) => {
>   /* some function stuff */
> }
> ```
>
> {/* prettier-ignore-end */}
>
> 在最初，人们都使用 `<T extends unknown>` （在 `unknown` 关键字存在之前是 `<T extends any>`）这种偏方；然而随着时间推移，人们发现 `<T,>` 这种写法更加便捷，而且 `,` 在 JSX 中不能用于分隔组件参数，但却能用于 TS 中。

### 题目说明

给 identity 函数添加类型定义。该函数传入什么就返回什么。

给 mapArray 函数添加类型定义。这题稍微有些烧脑，推荐一步一步来，首先思考 arr 的类型是什么？之后通过类型参数给 arr 提供泛型类型，最后思考函数 fn 的类型。

### 答案及分析

{/* prettier-ignore-start */}
```ts
const identity = <T,>(arg0: T): T => arg0

const mapArray = <T, R>(arr: T[], fn: (arg0: T) => R) => arr.map(fn);
```
{/* prettier-ignore-end */}

`identity` 函数通过泛型 `T` 知道了参数 arg0 的类型是什么。传入字符串 T 就是字符串类型；传入数字 T 就是数字类型。原封不动地返回 arg0，TS 便能推断出 `identity` 函数的返回值的类型。进而在测试中便能推断出 `typeof identity()` 的类型。

`mapArray` 函数同样需要一个泛型 `T`，由于在变量 arr 上调用了 map 方法，故 arr 肯定是数组。函数 fn 是传入 map 方法的 [callbackFn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#callbackfn)，有 element、index和 array 三个参数，但测试中的 fn 都只使用了第一个参数，所以在此不讨论第二、三个参数。

泛型 T 用于指示数组 arr 中元素的类型，同时也用于指示 fn 函数中第一个参数的类型；泛型 R 指示函数 fn 的返回值的类型，测试中的 `(str) => parseInt(str)` 表明 fn 函数的传入值 arg0 的类型和返回值的类型不同。

## Generic Type Arguments

### 为何需要泛型参数

若将原始类型看作变量，泛型就是能操作这些变量的函数。就如同函数有参数，泛型也需要能接受参数。

函数参数使用圆括号，泛型参数使用尖括号。甚至泛型参数中也有默认参数的概念，详情见 Default Generic Arguments。

```ts
interface Row<T> {
  label: string
  value: T
  disabled: boolean
}
```

上述代码定义了 Row 类型。其中有 value 属性，但 value 的类型要到使用 Row 类型时，向其中传入泛型 T 时才会知道（对于 TS 语法分析器来说）。

假设传入 Row 类型中的是 number 类型，则为：

```ts
type NumberRow = Row<number>
```

若是 string 类型，则为：

```ts
type StringRow = Row<string>
```

由于 TS 在对比类型时会分析其结构，`Row<string>` 和以下类型完全相等：

```ts
type StringRow = {
  label: string
  value: string
  disabled: boolean
}
```

使用泛型参数，可以直接用 `Row<string>` 来代替上述一大串代码，省略了其他参数的重复声明，也方便之后做改动。

当然泛型参数也可以有多个：

```ts
type GroceryItem<Name, Price, InStock> = {
  name: Name
  price: Price
  inStock: InStock
}

type AvocadoToast = GroceryItem<"Avocado Toast", 12.99, true>
```

在选择泛型名称时，推荐使用能描述类型用途的字符，`GroceryItem` 中的 `Name` 就好过于 `T`，前者一看就能明白，`Name` 或多或少可能是字符串类型。

`AvocadoToast` 类型和直接用原始类型定义的是完全等价的：

```ts
type AvocadoToast = {
  name: "Avocado Toast"
  price: 12.99
  inStock: true
}
```

> 擅长动脑的你可能想到了，如果故意传了错误的类型会发生什么？
>
> ```ts
> GroceryItem<number[], boolean, { over: 9000 }>
> ```
>
> 这一点请参考 Generic Type Constraints。

### 答案及分析

```ts
type GroceryStore<Name, City> = {
  name: Name
  city: City
}

type GroceryItem<Name, Price, InStock> = {
  name: Name
  price: Price
  inStock: InStock
}

type CapreseSalad = GroceryItem<"Caprese Salad", 14.99, true>
```

## Generic Type Constraints

### 泛型约束所解决的问题

在 Generic Type Arguments 中，我们将泛型参数描述为*类型世界*中的函数参数。

```ts
//             v-----v 函数参数
const drive = (carType: CarType) => {
  //                  ^-------^ 函数参数 类型限制
  // ....
}

//        v-------v 泛型参数
type Drive<CarType> = (carType: CarType) => {
  // ....
}
```

在泛型参数中，我们还需要限制传入的泛型 CarType 的类型，不然 CarType 可以接受任意类型的话，处理起来也不方便。

假设之前的 Row 类型中的泛型 T 可以是以下三种：

- `string`
- `number`
- `() => string | number`

可以写成：

```ts
type RowConstraints = string | number | (() => string | number)
```

> 在 Union 中定义函数类型时，要加上圆括号。

用 `extends` 关键字告诉 TS，传入 Row 中的泛型 T 只能是 RowConstraints 中的三种。

```ts
type Row<T extends RowConstraints> = {
  value: T
  label: string
  orientation: "vertical" | "horizontal"
}
```

如果我们传了不符合规定的类型，TS 会报错

```ts
type StringArrayRow = Row<string[]>
//                        ^?
// Type 'string[]' does not satisfy the constraint 'RowConstraints'.
```

### 答案及分析

前两个很简单，直接 `extends` 对应的类型。

第三个 `createLogger` 类型，从测试案例中可以看出，该类型接受一个函数类型的泛型，且该函数类型的首个参数是 number 类型；返回值是一个对象，其中有两个函数：log 函数和传入的泛型相同，exit 函数没有参数，没有返回值类型。

```ts
type AllowString<T extends string> = T
type AllowNumber<T extends number> = T

type CreateLogger<T extends (a: number) => void> = {
  log: T
  exit: () => void
}
```

## Index Signatures

假设后端有一个返回多个用户粉丝数的端口：

```txt
https://yourcompany.com/api/v1/followerCountByUser
```

```json
{
  "info": {
    "count": 9001,
    "currentPage": 1,
    "pages": 22
  },
  "results": {
    "user_ddb04d2e-21ff-4c68-9bdc-135c16c8e74a": 0,
    "user_1e118b25-c0b9-4bfc-8d04-901ad8a2eb20": 3,
    "user_7c56283c-6a5e-4d79-bdd0-9c6a3cafd2c4": 15,
    "user_2eac2f5e-4f11-4d36-84b5-9d273816d6f6": 7,
    "user_4b88b4a3-8d42-4fc9-9f73-8db296d9b03d": 88,
    "user_af836d5e-16a2-452d-bec4-694d6cd8e49f": 92,
    "user_610c236f-b3bb-45e9-a09b-1d7e362c7fbb": 14,
    "user_7a8e29f0-d7b0-4b75-9ad2-c8a145073eab": 6,
    "user_eaa914df-4650-4c3b-9a04-723b5a63f297": 764,
    "user_3199b7c6-7a8d-47eb-ae94-4e3457ad7760": 32
    // ... for many more rows in this page
  }
}
```

我们要如何给端口的返回值添加类型呢？

先不管 info 属性，results 中的值是多个字符串和数字组成的键值对儿，这就是*索引签名*的用武之地。

```ts
type Results = {
  [userId: string]: number
}
```

Results 类型的写法像极了 JS 中的 Object。`userId: string` 指示键名应该是字符串类型，之后的 number 表示值的类型。需要注意的是，此处的 userId 不一定非要写成 userId，可以写成其他字符串，其名称对 Results 类型的结果没有影响。

接口返回的类型可以定义成：

```ts
type Info = {
  count: number
  currentPage: number
  pages: number
}

type FollowerCountByUserResults = {
  [userId: string]: number
}

type FollowerCountByUser = {
  info: Info
  results: FollowerCountByUserResults
}
```

### 答案

根据测试用例，写出对应的类型即可。

```ts
type GroceryList = {
  [groceryItem: string]: number
}

type InappropriateActionBySituation = {
  [situation: string]: string[]
}

type CharactersById = {
  [id: number]: {
    id: number
    name: string
    status: string
    species: string
  }
}
```

## Indexed Types

### 索引类型的用途

索引类型可以访问其他类型中，某个属性的类型。

就像访问数组中的元素一样：

```js
const cars = ["Bugatti", "Ferarri", "Lambo", "Porsche", "Toyota Corolla"]
const secondCar = cars[1]
```

同样可以访问数组类型（元组）中的某个元素的类型：

```ts
type Cars = ["Bugatti", "Ferarri", "Lambo", "Porsche", "Toyota Corolla"]
type SecondCar = Cars[1]
//   ^? type SecondCar = "Ferarri"
```

> TS 将 SecondCar 的类型理解为 "Ferarri"，而非字符串！

对象类型也可以：

```js
const donations = {
  Bono: 15_000_000,
  "J.K. Rowling": 160_000_000,
  "Taylor Swift": 45_000_000,
  "Elton John": 600_000_000,
  "Angelina Jolie and Brad Pitt": 100_000_000,
}
const eltonDonations = donations["Elton John"]
```

```ts
type Donations = {
  Bono: 15_000_000
  "J.K. Rowling": 160_000_000
  "Taylor Swift": 45_000_000
  "Elton John": 600_000_000
  "Angelina Jolie and Brad Pitt": 100_000_000
}

type EltonDonations = Donations["Elton John"]
//   ^? type EltonDonations = 600000000
```

甚至是字符串类型：

```js
const question = "Have the humans delivered their ultimate cup of coffee?"
const firstCharacter = question[0]
```

```ts
type Question = "Have the humans delivered their ultimate cup of coffee?"
type FirstCharacter = Question[0]
//   ^? type FirstCharacter = string
```

> 但需要注意的是，此处的 FirstCharacter 是 string 类型，而非 'H' 类型。

实际上，TS 根本不会真的去检查（也不在乎）对应索引的位置的单个字符是什么，只是返回 string：

```ts
type Empty = ""
type IndexEmpty = Empty[9001]
//   ^? type IndexEmpty = string
```

> 如果真要实现返回字符串对应位置的字符的类型，也不是没有，但会涉及到一些相当高级的类型机制。

### 答案

```ts
type TheCoolestCarEverMade = Cars[4]
type TruckDriverBonusGiver = Donations["Taylor Swift"]
```

## The `keyof` operator

### `keyof` 的用法

`keyof` 用于将对象类型的所有键（或者说属性）取出，组成一个集合(Union)。

比如说有如下对象：

{/* prettier-ignore-start */}
```js
const casettesByArtist = {
  "Alanis Morissette": 2,
  "Mariah Carey": 8,
  "Nirvana": 3,
  "Oasis": 2,
  "Radiohead": 3,
  "No Doubt": 3,
  "Backstreet Boys": 3,
  "Spice Girls": 2,
  "Green Day": 2,
  "Pearl Jam": 5,
  "Metallica": 5,
  "Guns N' Roses": 2,
  "U2": 3,
  "Aerosmith": 4,
  "R.E.M.": 4,
  "Blur": 3,
  "The Smashing Pumpkins": 5,
  "Britney Spears": 3,
  "Whitney Houston": 3,
}
```
{/* prettier-ignore-end */}

我们想要的是，所有属性组成的集合的类型。我们需要先用 `typeof` 获取变量 `casettesByArtist` 的类型，其中的属性会转化为常量字符串类型。

```ts
type Artists = keyof typeof casettesByArtist
//   ^? type Artist = "Alanis Morissette" | ... 17 more ... | "Whitney Houston"
```

`keyof` 的返回类型总会是集合类型。

### 答案

```ts
type Artist = keyof typeof casettesByArtist
```

## Literal Types

### 字面类型的用法

在 JS 中，我们把 string、number 和 boolean 等类型叫做原始类型，即不可再分了。但 TS 对类型做了更加细致的划分。

以下是彩虹中所有颜色的集合类型：

```ts
type RainbowColor =
  | "red"
  | "orange"
  | "yellow"
  | "green"
  | "blue"
  | "indigo"
  | "violet"
```

我们可以用该类型确保，错误的类型不会被传入到函数中：

```ts
function pickColor(color: RainbowColor): void {
  console.log(`I choose the color ${color}!`)
}

// no error: TypeScript is happy!
pickColor("yellow")

// Error: Argument of type 'purple' is not assignable to parameter of type 'RainbowColor'.
pickColor("purple")
// ^?
```

字面类型也可以用于返回值的类型上：

```ts
type Day =
  | "Monday"
  | "Tuesday"
  | "Wednesday"
  | "Thursday"
  | "Friday"
  | "Saturday"
  | "Sunday"

const isItPartyTime = (day: Day) => {
  switch (day) {
    case "Friday":
    case "Saturday":
    case "Sunday":
      return "definitely party time"

    default:
      return "prolly lay low for now"
  }
}

isItPartyTime("Monday")
// ^? const isItPartyTime: (day: Day) => "definitely party time" | "prolly lay low for now"
```

可以看出，函数的返回值是两个字符串字面量类型组成的集合类型。

### 答案

```ts
type LiteralString = "chocolate chips"
type LiteralTrue = true
type LiteralNumbers = 1 | 2 | 3 | 4 | 5 | 6
type LiteralObject = {
  name: "chocolate chips"
  inStock: true
  kilograms: 5
}
type LiteralFunction = (a: number, b: number) => number

const literalString = "Ziltoid the Omniscient"
const literalTrue = true
const literalNumber = Math.random() > 0.5 ? 1 : 2
const almostPi = 3.141592653589793 // haha, it doesn't have such high accuracy
const literalObject = {
  origin: "string",
  command: "string",
  item: "string",
  time: "string",
}
const literalFunction = (a: number, b: string) => (true ? a : b) // stupid TS
```

## Mapped Object Types

### 对象映射

在数学中，`映射` 指将一个集合中的元素与另一个集合中的元素关联起来的函数。这就是计算机科学中“映射”一词的由来。

通过对现有的对象做类型映射，可以得到新的类型，也能使代码更加健壮、灵活和易于维护。随着你对 TS 的深入了解，你会发现自己经常需要使用映射来解决日常的类型转换。对象映射可以说是 TS 中最强大、最通用的特性之一。

### 如何使用

为了了解什么是对象映射，我们先从以下代码入手：

```ts
type MoviesByGenre = {
  action: "Die Hard"
  comedy: "Groundhog Day"
  sciFi: "Blade Runner"
  fantasy: "The Lord of the Rings: The Fellowship of the Ring"
  drama: "The Shawshank Redemption"
  horror: "The Shining"
  romance: "Titanic"
  animation: "Toy Story"
  thriller: "The Silence of the Lambs"
}

type MovieInfoByGenre<T> = {
  [K in keyof T]: T[K]
}

type Example = MovieInfoByGenre<MoviesByGenre>
```

如上代码的 `Example` 类型，和最初的 `MoviesByGenre` 类型完全一致，中间过程所做的一切，就是通过 `MovieInfoByGenre` 类型，把 `MoviesByGenre` 类型重新复制了一遍。

`MovieInfoByGenre` 类型接受一个泛型 T，在这个例子中就是 MoviesByGenre，keyof T 将 MoviesByGenre 中的所有属性提出，转换为常量字符串集合类型，K 是新的泛型名称，in 关键字代表要对 keyof T 进行遍历，也就是对集合类型进行遍历，K in keyof T 代表 K 在每次遍历中都是 keyof T 集合类型中的一个元素的类型，`T[K]` 则为在 MoviesByGenre 上访问对应属性的值。

### 答案

```ts
type Movie = {
  name: string
  year: number
  director: string
}

type MovieInfoByGenre<T> = Record<keyof T, Movie>
```

## Primitive Data Types

### 原始类型解决了什么问题

因为创建原始类型的能力是 TypeScript 的核心思想，所以问“原始类型解决了什么问题”更像是问“TypeScript 解决了什么问题”。

TypeScript 就像一个非常非常智能的拼写检查器。它能帮助你在状态最佳时提高工作效率，也能在你凌晨三点压力山大、论文截止日期临近时，帮你避免拼写错误。

仔细想想：拼写检查器之所以有效，是因为它们内置了关于英语词汇和语法的规则。类似地，TypeScript 也拥有关于 JavaScript 词汇和语法的高级知识。但 TypeScript 的优势在于，你可以指定数据类型。这使得 TypeScript 能够更准确地判断你尝试的操作是否可能存在 bug。

### `Primitive` 指的是什么

说到词语和语言，这里“原始”一词用法有点专业术语的味道。如果你查字典，“原始”一词的第一个定义是：

> 1: relating to, denoting, or preserving the character of an early stage in the evolutionary or historical development of something.

基本上是“古老的”或“未开发的”的意思

非也，这个词在这个语境中并不是这个意思。如果你继续往下看，你会发现一个不太常用的定义：

> 3: not developed or derived from anything else.

这样解释就合理多了。这就是原始类型。它们是信息的基本单元，其他一切都由此派生而来。

实际上，所有 TS 类型都派生自原始类型（除了极少数极其罕见的例外，大多数人甚至都不知道）。

### 什么是原始类型

原始类型均为小写字母开头：

- `number`：由于 JS 中只有一种数字类型（IEEE-754，64 位浮点数），TS 便没有和其他编程语言一样，创建了 short、long 或者 uint32、unit16 等，而是直接使用了 number 类型。
- `string`：可变长度字符集（UTF-16）。
- `boolean`：不要为接下来的这句话感到困惑，但 boolean 在 TS 中并不是原始类型，与 string 或 number 略有不同，它是 true 和 false 并集的别名。它不像 number 和 string 那样有字面常量类型。
- `null`：JS 中 null 有些特殊，所以在 TS 中，它也有着以自己为命名的独特类型。
- `undefined`：和 null 类型，是 JS 中的一个特定值，也有着与自己对应的类型。

另外，TS 中其他有名有姓的类型还有：

- `symbol`
- `bigint`
- `object`
- `never`
- `unknown`
- `any`

组要注意的是，大写字母开头的如：Number、String、Boolean、Symbol、Object 等，这些都是 JS 中的概念，一般情况下不会用于 TS 中。

### 答案

```ts
interface Musician {
  artistName: string
  age: number
  deceased: boolean
}

const playSong = (artistName: Musician["artistName"], year: number) => {
  return `${artistName} was released in the year ${year}`
}

const artistName: Musician["artistName"] = "Frank Zappa"
const age: Musician["age"] = 52

const musicianInfo = (musician: Musician) => {
  return `${musician.artistName}, age ${musician.age}${musician.deceased ? " (deceased)" : ""}`
}

musicianInfo({
  artistName,
  age,
  deceased: true,
})
```

## Type Aliases

1999 年 9 月 23 日，价值 1.25 亿美元的火星气候探测器，因为使用的单位类型不同，而坠毁在火星。

> 耗资 1.25 亿美元的火星气候探测器于 1999 年 9 月 23 日失事，原因是两个工程团队在推进器性能数据方面存在差异：一个团队使用英制单位（磅秒），另一个团队使用公制单位（牛顿秒）。这种单位不匹配导致探测器比预期更靠近火星约 100公里（60英里），最终在火星大气层中烧毁。

```ts
/**
 * 根据距着陆点的距离计算着陆推进器
 */
const landSpacecraft = (distance: number) => {
  // ... do fancy math here
}
```

如果能把 distance 的类型换成比 number 更精确一点的会更好。

```ts
/** International System of Units Meter */
type Meters = number

const landSpacecraft = (distance: Meters) => {
  // ... do fancy math here
}
```

但如上代码所做的，只不过是将 number 换了一个名称而已，并不会因为传入 Miles 类型（也是 number）的参数而报错。

```ts
/** In */
type Miles = number

const targetDistance: Miles = 100

landSpacecraft(targetDistance)
```

实际上，TS 中存在一种更管用的方式，用来区分不同的自定义类型，但这需要用到集合类型，详见 Type Unions。

创建别名非常简单：

```ts
type MyAlias = number
```

但注意不要过度的定义别名。比如为某个类型的数组类型专门定义一个名称：

```ts
export interface Row {
  // imagine some properties here
}

export type Rows = Row[]
```

给 Row 的数组类型起别名叫 Rows 感觉起来很合理，这样在其他文件中直接导入 Rows 就可以了。

但这么做之前，再多想一步：导入 Row 类型在加上 `[]` 不是也行嘛，毕竟多写一组方括号也废不了多少时间。

另外，在同一个文件中也很可能会用到 Row 类型，这样也更容易阅读和理解代码。

### 答案

```ts
type Name = string
type Year = number
type IsOperational = boolean
type Kilograms = number
type Count = number

type Payload = {
  name: Name
  mass: Kilograms
}
```

## The `typeof` Operator

### TS 与 JS 之间的桥梁

|              |                  JS                  |       TS       |
| ------------ | :----------------------------------: | :------------: |
| 变量         |       `cosnt`，`let`，函数参数       |    类型别名    |
| 操作         | for 循环，while 循环，递归，高等函数 | 递归，高等类型 |
| 是否有运行   |                  是                  |       否       |
| 什么时候报错 |                运行时                |     编译时     |
| 组成         |             语句和表达式             |     表达式     |

```txt
raw data
|              conversion
|              |            types
|              |            |
v              v            v
JavaScript ==> `typeof` ==> TypeScript
```

### 如何使用 `typeof`

在 JS 中，typeof 以字符串的形式返回变量的类型：

```js
console.log(typeof "Euler's Number")
// -> logs the string `'string'`

console.log(typeof 2.7182)
// -> logs the string `'number'`
```

在 TS 中：

```ts
const name = "Euler's Number"
const value = 2.7182

// we can use `typeof` for type aliases
type Value = typeof value

interface FamousNumbers {
  // or we can use it inline
  label: typeof name
  value: Value
}
```

```ts
const count = 42
type Count = typeof count
```

typeof 在操作复杂类型时很有帮助，typeof 一般放在 JS 变量之前：

```ts
const createPoint = (x: number, y: number) => ({ x, y })
```

typeof 可用于提取该函数的类型，并运用到 TS 中。

```ts
//                        JavaScript stuff
//                        |
//                        v----------
type CreatePoint = typeof createPoint
//^----------------------
//|
//|TypeScript stuff
```

### 答案

```ts
type Width = typeof width
type Margin = typeof margin
type Data = (typeof d3ChartConfig)["data"]
type YScale = (typeof d3ChartConfig)["yScale"]

type D3ChartConfig = typeof d3ChartConfig
```

## Default Generic Arguments

技术上讲，没有一个编程语言需要默认参数这一概念，这只是为了方便程序员才引入的便捷设计。

### 如何给类型参数加上默认值

```ts
type LogLevel = "debug" | "info" | "notice" | "warning" | "error" | "critical"

const log = (message: string, level: LogLevel = "info") => {
  // application logic
}

log("this has an explicit debug log level", "debug")
log("this has an implicit info debug level")
```

同样地，默认值也能用在泛型上。这又是函数和泛型类型之间的另一个相似之处。

```ts
type Log<Message, Level = "info"> = {
  message: Message
  level: Level
}

type ExplicitDebugLog = Log<"explicit debug", "debug">
type ImplicitInfo = Log<"implicit info">
```

是不是看着很眼熟？很多能用于函数参数默认值的语法，也都能用于类型上。

需要注意的是，TS 不会像 JS 中的那样，传入 undefined 从而使用默认参数：

```js
const greet = (name = "Stranger") => {
  console.log(`Hello ${name}!`)
}

greet() // Hello Stranger!
greet(undefined) // Hello Stranger!
greet("Mr. Monkey") // Hello Mr. Monkey!
```

### 答案

```ts
type Method = "GET" | "POST" | "UPDATE" | "PATCH" | "DELETE"

type ApiRequest<T, Method = "GET"> = {
  data: T
  method: Method
}

type TSConfig<T = { strict: true }> = {
  [K in keyof T]: T[K]
}
```

## Type Unions

在 Type Aliases 中，我们定义了 Meters 和 Miles 两种类型，为的就是只使用其中之一的类型。

```ts
type Meters = number;
type Miles = number;

const landSpacecraft = (distance: Meters) {
  // ... do fancy math ...
}
```

但实际传入值后，却没有像预期的那样报错：

```ts
const distanceInMiles: Miles = 1242
landSpacecraft(distanceInMiles)
```

此时，我们可以使用集合。

集合类型通过`管道`字符来定义。

```ts
type Meters = number
type Miles = number

type Distance = Meters | Miles
```

这种写法只是把两个 number 类型并在了一起，并不能区分哪一个是哪一个。

```ts
type Meters = {
  unit: "meters"
  value: number
}

type Miles = {
  unit: "miles"
  value: number
}

type Distance = Meters | Miles
```

然后在更新 landSpacecraft 函数：

```ts
const landSpacecraft = (distance: Distance) => {
  let meters: Meters = {
    unit: "meters",
    value:
      distance.unit === "miles" ? distance.value / 1609.34 : distance.value,
  }
  // ... rest of our code
}
```

关于类型集合，目前需要注意的有三点：

1. 集合是无序的：
2. 集合中的元素是唯一的：`1 | 1 | 2 | 3` 和 `1 | 2 | 3` 一样的
3. `never` 类型属于空集：这点我们之后细说

### 答案

```ts
// Part 1: Meters
type Meters = {
  unit: "meters" | "feet"
  value: number
}

type Miles = {
  unit: "miles"
  value: number
}

type Distance = Meters | Miles

// Part 2: position
type Orientation = {
  x: "right" | "left"
  y: "top" | "bottom"
  z: "center"
}

type Position =
  | Orientation[keyof Orientation]
  | `${Orientation["y"]}${Capitalize<Orientation["x"]>}`
```
